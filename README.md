
# LCache

`LCache` 是一个高性能的本地缓存库，支持两种缓存策略：

- `LRU`（最近最少使用）
- `LRU-2`（两级缓存：频率 + 时间综合优化）

该项目用 Go 语言实现，支持缓存淘汰、过期控制、分桶并发、内存限制与回调等高级功能，适合作为分布式缓存组件、API 本地缓存等应用场景。

---

## 📦 功能特性

- ✅ 基于 Go 手写双向链表实现高性能缓存结构
- ✅ 支持 TTL（过期时间）、Eviction（淘汰回调）
- ✅ 支持 LRU 和 LRU-2 两种策略，适配不同业务场景
- ✅ LRU-2 使用两级缓存设计：L1（近期访问）+ L2（高频使用）
- ✅ 多 bucket 分桶并发，提升吞吐能力
- ✅ 提供统一接口 `Store`，策略可插拔替换
- ✅ 提供清理协程，自动清除过期项

---

## 📂 模块结构

```
LCache/
├── store/
│   ├── lru.go         # 单级 LRU 缓存实现
│   ├── lru2.go        # 两级 LRU 缓存（LRU-2）实现
│   └── store.go       # 通用缓存接口与策略选择器
├── main.go            # 示例或入口文件（可选）
├── go.mod
└── README.md
```

---

## 🧠 缓存策略对比

| 策略   | 特点                                 | 适用场景                     |
|--------|--------------------------------------|------------------------------|
| LRU    | 最近最少使用，保留近期访问数据         | 内存有限、访问热点集中        |
| LRU-2  | 先进入 L1，访问后晋升 L2，高频保留更久 | 热点频率分层、大数据缓存控制 |

---

## 🛠️ 使用方式

```go
import "your_module/store"

opts := store.NewOptions()
cache := store.NewStore(store.LRU2, opts)

cache.Set("k1", MyValue{"hello"})
val, ok := cache.Get("k1")
```

其中 `MyValue` 需要实现如下接口：

```go
type Value interface {
    Len() int // 返回字节大小，用于内存估算
}
```

---

## 📌 进度记录

| 日期       | 进度说明                     |
|------------|------------------------------|
| 2025-05-08 | ✅ 完成 `lru.go` 单级 LRU     |
| 2025-05-08 | ✅ 完成 `lru2.go` 双级缓存     |
| 2025-05-08 | ✅ 统一封装接口于 `store.go`  |

---

## 📄 TODO（后续计划）

- [ ] 添加缓存统计（命中率、访问次数）
- [ ] 提供 benchmark 压测文件
- [ ] 支持主动降级 / 异常恢复机制
- [ ] 添加完整测试覆盖率（目前部分测试待修复）

---

## 📃 License

MIT License
